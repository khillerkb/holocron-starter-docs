import { EventEmitter } from 'events';

// src/Sema.ts

// src/Deque.ts
var MIN_CAPACITY = 4;
var MAX_CAPACITY = 1073741824;
var RESIZE_MULTIPLER = 1;
function arrayMove(list, srcIndex, dstIndex, numberOfElements) {
  for (let j = 0; j < numberOfElements; ++j) {
    list[j + dstIndex] = list[j + srcIndex];
    list[j + srcIndex] = void 0;
  }
}
function pow2AtLeast(n) {
  n >>>= 0;
  n -= 1;
  n |= n >> 1;
  n |= n >> 2;
  n |= n >> 4;
  n |= n >> 8;
  n |= n >> 16;
  return n + 1;
}
function getCapacity(capacity) {
  return pow2AtLeast(Math.min(Math.max(MIN_CAPACITY, capacity), MAX_CAPACITY));
}
var Deque = class {
  _capacity;
  _length;
  _front;
  arr;
  constructor(initialCapacity = 4) {
    this._capacity = getCapacity(initialCapacity);
    this._length = 0;
    this._front = 0;
    this.arr = [];
  }
  push(item) {
    const length = this._length;
    this.checkCapacity(length + 1);
    const i = this._front + length & this._capacity - 1;
    this.arr[i] = item;
    this._length = length + 1;
    return length + 1;
  }
  pop() {
    const length = this._length;
    if (length === 0)
      return;
    const i = this._front + length - 1 & this._capacity - 1;
    const ret = this.arr[i];
    this.arr[i] = void 0;
    this._length = length - 1;
    return ret;
  }
  shift() {
    const length = this._length;
    if (length === 0)
      return;
    const front = this._front;
    const ret = this.arr[front];
    this.arr[front] = void 0;
    this._front = front + 1 & this._capacity - 1;
    this._length = length - 1;
    return ret;
  }
  get length() {
    return this._length;
  }
  checkCapacity(size) {
    if (this._capacity < size) {
      this.resizeTo(getCapacity(this._capacity * RESIZE_MULTIPLER + MIN_CAPACITY));
    }
  }
  resizeTo(capacity) {
    const oldCapacity = this._capacity;
    this._capacity = capacity;
    const front = this._front;
    const length = this._length;
    if (front + length > oldCapacity) {
      const moveItemsCount = front + length & oldCapacity - 1;
      arrayMove(this.arr, 0, oldCapacity, moveItemsCount);
    }
  }
};

// src/Sema.ts
var DEFAULT_INIT_VALUE = "1";
function isFn(x) {
  return typeof x === "function";
}
var Sema = class {
  maxConcurrency;
  freeQ;
  waitingQ;
  releaseEmitter;
  noTokens;
  pauseFn;
  resumeFn;
  paused;
  constructor(maxConcurrency, {
    initFn,
    pauseFn,
    resumeFn,
    capacity = 10
  } = {}) {
    if (isFn(pauseFn) && !isFn(resumeFn)) {
      throw new Error("pauseFn and resumeFn must be both set for pausing");
    }
    this.maxConcurrency = maxConcurrency;
    this.freeQ = new Deque(maxConcurrency);
    this.waitingQ = new Deque(capacity);
    this.releaseEmitter = new EventEmitter();
    this.noTokens = initFn == null;
    this.pauseFn = pauseFn;
    this.resumeFn = resumeFn;
    this.paused = false;
    this.releaseEmitter.on("release", (token) => {
      const p = this.waitingQ.shift();
      if (p) {
        p.resolve(token);
      } else {
        if (this.resumeFn && this.paused) {
          this.paused = false;
          this.resumeFn();
        }
        this.freeQ.push(token);
      }
    });
    for (let i = 0; i < maxConcurrency; i += 1) {
      const init = initFn ? initFn() : DEFAULT_INIT_VALUE;
      this.freeQ.push(init);
    }
  }
  tryAcquire() {
    return this.freeQ.pop();
  }
  async acquire() {
    const token = this.tryAcquire();
    if (token !== void 0) {
      return token;
    }
    return new Promise((resolve, reject) => {
      if (this.pauseFn && !this.paused) {
        this.paused = true;
        this.pauseFn();
      }
      this.waitingQ.push({ resolve, reject });
    });
  }
  release(token) {
    this.releaseEmitter.emit("release", this.noTokens ? DEFAULT_INIT_VALUE : token);
  }
  drain() {
    const a = new Array(this.maxConcurrency);
    for (let i = 0; i < this.maxConcurrency; i += 1) {
      a[i] = this.acquire();
    }
    return Promise.all(a);
  }
  waiting() {
    return this.waitingQ.length;
  }
};

// src/RateLimit.ts
var RateLimit = class {
  sema;
  delay;
  timeouts = [];
  constructor(rate, {
    interval = 1e3,
    uniformDistribution = false
  } = {}) {
    if (!Number.isInteger(rate) || rate < 0) {
      throw new TypeError(
        "The rate-limit-per-time-unit (rptu) should be an integer and greater than zero"
      );
    }
    this.sema = new Sema(uniformDistribution ? 1 : rate);
    this.delay = uniformDistribution ? interval / rate : interval;
  }
  async apply() {
    await this.sema.acquire();
    const tm = setTimeout(() => this.sema.release(), this.delay);
    this.timeouts.push(tm);
    return tm;
  }
  reset() {
    const timeoutsToClear = this.timeouts.length;
    this.timeouts.forEach((t) => {
      clearTimeout(t);
      this.sema.release();
    });
    this.timeouts = [];
    return timeoutsToClear;
  }
};

export { RateLimit, Sema };
