export let docsRpcClient = {
    async setDocsState(state) {
        console.warn(new Error(`docs rpc client still not initialized`));
    },
    cleanup() { },
};
export function createIframeRpcClient({ ws, defaultTimeout = 1000 * 5 }) {
    const pendingRequests = new Map();
    const usedIdempotenceIds = new Set();
    docsRpcClient.setDocsState = async ({ idempotenceKey, state, revalidate, }) => {
        if (!ws || ws.readyState !== 1) {
            throw new Error('WebSocket instance not open.');
        }
        const id = crypto.randomUUID();
        const message = {
            id,
            state,
            revalidate,
        };
        return new Promise((resolve, reject) => {
            // If idempotenceKey is specified and already used, return resolved promise immediately
            if (idempotenceKey && usedIdempotenceIds.has(idempotenceKey)) {
                console.log(`Idempotence ID ${idempotenceKey} already used, skipping docs state set state`);
                return Promise.resolve(undefined);
            }
            const timeout = setTimeout(() => {
                pendingRequests.delete(id);
                reject(new Error(`Request ${id} timed out after ${defaultTimeout}ms`));
            }, defaultTimeout);
            pendingRequests.set(id, { resolve, reject, timeout });
            ws.send(JSON.stringify(message));
            if (idempotenceKey) {
                usedIdempotenceIds.add(idempotenceKey);
            }
        });
    };
    function onMessage(data, isBinary) {
        let msg;
        try {
            // Only parse if not binary
            if (isBinary)
                return;
            msg = JSON.parse(data.toString());
        }
        catch (err) {
            // ignore parse errors
            return;
        }
        if (!msg)
            return;
        const { id, state, error } = msg;
        if (!id)
            return;
        const pending = pendingRequests.get(id);
        if (!pending)
            return;
        pendingRequests.delete(id);
        clearTimeout(pending.timeout);
        if (error) {
            pending.reject(new Error(error));
        }
        else {
            pending.resolve(state);
        }
    }
    // Attach ws 'message' event handler
    // handle multiple calls gracefully
    function messageHandler(data, isBinary) {
        onMessage(data, isBinary);
    }
    ws.on('message', messageHandler);
    docsRpcClient.cleanup = () => {
        ws.off('message', messageHandler);
        // Clean up any pending requests
        for (const [id, pending] of Array.from(pendingRequests)) {
            clearTimeout(pending.timeout);
            pending.reject(new Error('RPC client cleanup'));
        }
        pendingRequests.clear();
        usedIdempotenceIds.clear();
    };
    return docsRpcClient;
}
//# sourceMappingURL=setstate.js.map